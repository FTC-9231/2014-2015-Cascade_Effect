#pragma config(Sensor, S1,     rightLight,     sensorLightActive)
#pragma config(Sensor, S2,     leftLight,      sensorLightActive)
#pragma config(Sensor, S3,     range,          sensorSONAR)
#pragma config(Sensor, S4,     touch,          sensorNone)
#pragma config(Motor,  motorA,          leftWheel,    tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightWheel,   tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickDriver.c"
#include "filters.c"
#include "joystickButtons.h"
#include "toggleButton.c"

#define JoyThreshold 4
#define WheelMotorRampLimit 1

task main()
{
	// since the ThresholdFilter is stateless, we can share it between both joysticks
	ThresholdFilter joyTF;
	ThresholdFilter_init(&joyTF, JoyThreshold);

	// define a separate filter for each joystick because it remembers state
	RampFilter rampJoy1;
	RampFilter_init(&rampJoy1, WheelMotorRampLimit, 0);
	RampFilter rampJoy2;
	RampFilter_init(&rampJoy2, WheelMotorRampLimit, 0);
	AverageFilter filterRange;
	AverageFilter_init(&filterRange, 50, 40);		// average last 50 readings, initial value 40

	// define a toggle button to switch between steering modes
	ToggleButton modeTB;
	ToggleButton_init(&modeTB, ButtonA, 2, 1);


	while (true)
	{
		getJoystickSettings(joystick);

		// do some filtering of sonar range data
		short rng = SensorValue(range);
		if (rng == 255)
			rng = 100;		// far away ...
		AverageFilter_process(&filterRange, rng);		// update filter and get new filtered value
		rng = AverageFilter_value(&filterRange);

		// scale down speed whenever we're near something in front of us
		float scale = 100.0 / (128 + 128/2);
		if (rng < 40)
			scale *= rng / 40.0;

		// display range and speed scale estimates on NXT
		eraseDisplay();
		nxtDisplayStringAt(0,60,"rng=%f",rng);
		nxtDisplayStringAt(0,50,"sc=%f",scale);

		// select one of two driving modes with toggle button A
		short left, right;
		ToggleButton_process(&modeTB);
		if (ToggleButton_value(&modeTB))
		{
			// one joystick (left) driving
			left = (short)(scale*(joystick.joy1_y1 + joystick.joy1_x1/2));
			right = (short)(scale*(joystick.joy1_y1 - joystick.joy1_x1/2));
		}
		else
		{
			// tank-style two joystick driving
			left = (short)(scale*joystick.joy1_y1);
			right = (short)(scale*joystick.joy1_y2);
		}

		// feed the joystick inputs through filters before assigning to the wheel motors
		motor[leftWheel] = RampFilter_process(&rampJoy1, ThresholdFilter_process(&joyTF, left));
		motor[rightWheel] = RampFilter_process(&rampJoy2, ThresholdFilter_process(&joyTF, right));

	}
}
